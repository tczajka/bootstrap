# x86-64 machine code

[TOC]

We write all our code for x86-64 CPUs in 64-bit mode.

It is a complicated instruction set. But we will deal with it. We only describe some
common instructions that will be useful to us.

## Registers

There are 16 64-bit registers:

ID  | name  | special uses
--: | ----- | ----------
`0` | `rax` | some arithmetic instructions use it implicitly
`1` | `rcx` |
`2` | `rdx` |
`3` | `rbx` |
`4` | `rsp` | stack pointer (stack grows down)
`5` | `rbp` | stack frame pointer
`6` | `rsi` | source for string operations
`7` | `rdi` | destination for string operations
`8` | `r8`  |
`9` | `r9`  |
`10`| `r10` |
`11`| `r11` |
`12`| `r12` |
`13`| `r13` |
`14`| `r14` |
`15`| `r15` |

## Moves

Mov instructions copy data between registers and/or memory. The basic `mov` instruction
looks like this:

![mov](../images/mov.svg)

This moves data between a register and another register or memory.

### Move size

The size of the move is indicated by the `S` (size) and `W` (wide) bits as follows:

`S` | `W`| size     | notation
--- | -- | ----     | ---
  0 |  0 | 1 byte   | `mov.1` (don't use `rsp`, `rbp`, `rsi` or `rdi`)
  1 |  0 | 4 bytes  | `mov.4`
  1 |  1 | 8 bytes  | `mov.8`

There is also a way to specify 2 bytes , but let's ignore that.
It's *not* done by setting the bits to `0 1` (the remaining combination), as you might think!

Whenever 1 byte is moved to or from a register, it is lowest byte of the register.
However, for historical reasons there is an exception. If you specify register number
4-7, and there is no REX byte, it actually means the *second lowest* byte of a register
0-3. We will probably not need this functionality. We just have to be careful not to
try to use the single lowest byte in `rsp`, `rbp`, `rsi` or `rdi`.

Whenever 4 bytes are set in a register (via a `mov` or another operation),
the upper 4 bytes are zeroed.

### Move direction

The `D` (direction) bit specifies the move direction:

`D` | direction  | notation
--- | -------    | ---
 0  | `mem` <- `reg` (store) | `mov mem, reg`
 1  | `reg` <- `mem` (load)  | `mov reg, mem`

## Memory addressing: ModRM byte

The purpose of the ModRM byte is to describe which register to use, and which
location in memory (or another register) to use.

The register is simpler: it's described by the 4 bits: `R reg` (where `R` comes from the
REX byte). We need the REX.R bit if we want to use registers `r8-r15`.

The memory location depends on the `mod` field.

### `[register]` addressing

`mod = 00`. This mode specifies that the register number `B rm`
(where B comes from the REX byte) contains a memory address.

![ModRM\_00](../images/modrm_00.svg)

A gotcha: we can't use `rm = 4` or `rm = 5` in this mode!
4 is reserved for [SIB addressing](#sib-addressing).
5 is reserved for [relative addressing](#relative-addressing).

This means we can't say `[rsp]`, `[rbp]`, `[r12]` or `[r13]` using this mode.
x86-64 is complicated...

Let's encode an example instruction:

```nasm
    mov.4 rbx, [rcx]
```

This instruction moves 4 bytes from memory location addressed by `rcx` to the register `rbx`,
filling the top 4 bytes of `rbx` with 0.

We don't need the REX byte for this. We set `D=1` (load from memory), `S = 1` (4-byte move), 
`mod = 00`, `reg = 3` (`rbx`), `rm = 1` (`rcx`).

![mov\_example1](../images/modrm_00_example.svg)

This gives us machine code in octal:
`%213 %031`.
Octal is very convenient because we have groups of 3 bits!

### `[register + const.1]` addressing

`mod = 01`. The register number `B rm` contains a memory address,
but we add a 1-byte signed constant to it.

![ModRM\_01](../images/modrm_01.svg)

`rm = 4` is reserved for [SIB addressing](#sib-addressing), so we can't say `[rsp + const.1]`
or `[r12 + const.1]` in this mode.

### `[register + const.4]` addressing

`mod = 10`. The register number `B rm` contains a memory address,
but we add a 4-byte signed constant to it.

![ModRM\_10](../images/modrm_10.svg)

`rm = 4` is reserved for [SIB addressing](#sib-addressing), so we can't say `[rsb + const.4]`
or `[r12 + const.4]` in this mode.

### Two-register operations

`mod = 11`. This time the second operand is simply the register indexed `B rm`.
Note that we can describe such a move instruction in two ways, in either direction (`D` bit).

![ModRM\_11](../images/modrm_11.svg)

### Relative addressing

Relative addresses are specified relative to the address of the next instruction:
`[next instruction + offset.4]`.

### SIB addressing

SIB addressing is the most complicated form of addressing on x86-64.
We will skip that here because we'll probably not use it.
It allows you to specify addresses of the form
`[base register + 2^power * index register + offset]`.

## Move a constant to `rax`

machine code | assembly      | description
------------ | ------------- | -----------
`%26x $y`    | `movb x, $y`  | load byte constant
`%27x #y`    | `mov x, #y`   | load dword constant

## Arithmetic and logic

Basic arithmetic instructions are encoded similarly to moves:

machine code | assembly      | description
------------ | ------------- | -----------
`%0p2 %3xy`  | `opb x, y`    | byte arithmetic
`%0p3 %3xy`  | `op x, y`     | dword arithmetic
`%0p0 %0xy`  | `opb [y], x`  | byte arithmetic to memory
`%0p1 %0xy`  | `op [y], x`   | dword arithmetic to memory
`%0p2 %0xy`  | `opb x, [y]`  | byte arithmetic from memory
`%0p3 %0xy`  | `opb x, [y]`  | dword arithmetic from memory
`%0p4 $y`    | `opb al, $y`  | byte arithmetic of `al` with a constant
`%0p5 #y`    | `op eax, #y`  | dword arithmetic of `eax` with a constant
`%200 %3px $y` | `opb x, $y` | byte arithmetic with a constant
`%201 %3px #y` | `op x, #y`  | dword arithmetic with a constant
`%203 %3px $y` | `op x, $y`  | dword arithmetic with a sign-extended byte constant

Where `p` is one of 8 basic arithmetic and logic operations:

ID   | op        | description
---: | --------- | -----------
`0`  | `add`     | addition
`1`  | `or`      | bitwise or
`2`  | `adc`     | add with carry
`3`  | `sbb`     | subtract with borrow
`4`  | `and`     | bitwise and
`5`  | `sub`     | subtraction
`6`  | `xor`     | exclusive or
`7`  | `cmp`     | compare (`sub` without storing result)

Other arithmetic instructions:

machine code | assembly      | description
------------ | ------------- | ---------------
`%10x`       | `inc x`       | increment dword by 1
`%11x`       | `dec x`       | decrement dword by 1
`%204 %3xy`  | `testb x, y`  | `andb x, y` without storing the result
`%205 %3xy`  | `test x, y`   | `and x, y` without storing the result
`%301 %34x $y` | `shl x, $y` | shift dword `x` left by `y` bits
`%301 %35x $y` | `shr x, $y` | signed shift dword `x` right by `y` bits
`%301 %37x $y` | `sar x, $y` | unsigned shift dword `x` right by `y` bits

## String operations

machine code | assembly      | description
------------ | ------------- | ---------------
`%252`       | `stosb`       | write byte al into `[edi]`, increment `edi` by 1
`%253`       | `stosd`       | write dword eax into `[edi]`, increment `edi` by 4
`%254`       | `lodsb`       | read byte `[esi]` into `al`, increment `esi` by 1
`%255`       | `lodsd`       | read dword `[esi]` into `eax`, increment `esi` by 4

## Stack operations

Pushing on the stack means decrementing esp by 4 and storing the value at `[esp]`.
Popping off the stack is the opposite operation.

Calling a function pushes the return address on the stack. Returning from the function pops
it off the stack.

machine code | assembly      | description
------------ | ------------- | ---------------
`%12x`       | `push x`      | push dword on the stack
`%13x`       | `pop x`       | pop dowrd off the stack
`%350 #rel`  | `call #rel`   | call function, `rel`: 32-bit relative address
`%303`       | `ret`         | return from a function

## Jumps

machine code | assembly    | description
------------ | ----------- | ---------------
`%353 $rel`  | `jmp $rel`  | jump, `rel`: 8-bit relative address
`%351 #rel`  | `jmp long #rel` | long jump, `rel`: 32-bit relative address
`$7q $rel`   | `jq $rel`   | conditional jump, `q`: condition, `rel`: 8-bit relative address
`%017 $8q #rel` | `jq long #rel` | conditional long jump, `q`: condition, `rel`: 32-bit relative address

Conditional jumps are easiest to write in hexadecimal. `$7q` corresponds to `%16x` or `%17x` in octal.

Possible conditions are as follows:

ID  | condition   | description
--: | ----------- | --------------
`0` | `o`         | signed overflow
`1` | `no`        | signed no overflow
`2` | `c` / `b`   | unsigned carry or <
`3` | `nc` / `ae` | unsigned no carry or >=
`4` | `e` / `z`   | equal or zero
`5` | `ne` / `nz` | not equal or not zero
`6` | `be`        | unsigned <=
`7` | `a`         | unsigned >
`8` | `s`         | signed < 0
`9` | `ns`        | signed >= 0
`A` | `p`         | odd parity
`B` | `np`        | even parity
`C` | `l`         | signed <
`D` | `ge`        | signed >=
`E` | `le`        | signed <=
`F` | `g`         | signed >

## Software interrupts

A [system call](syscalls.md) is achieved by calling software interrupt `$80`.

machine code | assembly      | description
------------ | ------------- | ---------------
`%315 $x`    | `int $x`      | software interrupt number `x`
