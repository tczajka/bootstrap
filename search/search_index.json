{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bootstrapping a compiler We are going to bootstrap a compiler for a high level programming language without using another programming language. Not even assembly. We are going to build our tools from scratch! Before we get there, it will take a lot of little steps. And we will learn a lot in the process. Where do we start? We assume we have a computer with a Linux operating system and a terminal running bash . We will use some basic Linux command line utilities such as echo and cat and a text editor such as vi, emacs or gedit. We could make do even without these tools and build our own operating system and a text editor from scratch. But we'll not tie our hands that much. Maybe some day. We will build our tools in phases: * We have to start somewhere. Our first programs will be built from the command line using echo . * Octal . This will let us write code as a sequence of numbers in octal (base 8) in a text file and get them translated to a binary file. Why base 8? It is simple to parse, and x86 machine code opcodes are easiest to understand in base 8. * Bytes . This will make our lifes somewhat easier. It will allow us to use octal and hexadecimal, comments, and refer to addresses by labels. * Stack . A stack-based programming language inspired by Forth. * Brooklyn . A programming language similar to C or Pascal. * Tetris . The game. All the code is available in the src directory of the github repository . The Makefile has all the build steps. So if you want to see a program in action rather than repeat the whole process yourself, you can build any step in the tutorial using make : $ make bin/hello.1 [...] $ bin/hello.1 Hello, world!","title":"Home"},{"location":"#bootstrapping-a-compiler","text":"We are going to bootstrap a compiler for a high level programming language without using another programming language. Not even assembly. We are going to build our tools from scratch! Before we get there, it will take a lot of little steps. And we will learn a lot in the process. Where do we start? We assume we have a computer with a Linux operating system and a terminal running bash . We will use some basic Linux command line utilities such as echo and cat and a text editor such as vi, emacs or gedit. We could make do even without these tools and build our own operating system and a text editor from scratch. But we'll not tie our hands that much. Maybe some day. We will build our tools in phases: * We have to start somewhere. Our first programs will be built from the command line using echo . * Octal . This will let us write code as a sequence of numbers in octal (base 8) in a text file and get them translated to a binary file. Why base 8? It is simple to parse, and x86 machine code opcodes are easiest to understand in base 8. * Bytes . This will make our lifes somewhat easier. It will allow us to use octal and hexadecimal, comments, and refer to addresses by labels. * Stack . A stack-based programming language inspired by Forth. * Brooklyn . A programming language similar to C or Pascal. * Tetris . The game. All the code is available in the src directory of the github repository . The Makefile has all the build steps. So if you want to see a program in action rather than repeat the whole process yourself, you can build any step in the tutorial using make : $ make bin/hello.1 [...] $ bin/hello.1 Hello, world!","title":"Bootstrapping a compiler"},{"location":"reference/ascii/","text":"ASCII Each ASCII character corresponds to a byte in the range 0-127 (hex 0-7F). Rows correspond to the first hex digit, colums to the second hex digit. 0 1 2 3 4 5 6 7 8 9 A B C D E F 0 HT LF VT FF CR 1 2 SP ! \" # $ % & ' ( ) * + , - . / 3 0 1 2 3 4 5 6 7 8 9 : ; < = > ? 4 @ A B C D E F G H I J K L M N O 5 P Q R S T U V W X Y Z [ \\ ] ^ _ 6 ` a b c d e f g h i j k l m n o 7 p q r s t u v w x y z { | } ~ Whitespace characters: * SP: space * LF: end of line (\"line feed\") * HT: tab (\"horizontal tab\") * CR: alternate end of line (\"carriage return\"). Windows editors commonly end lines with two characters: CR LF. * VT: vertical tab, rarely used * FF: end of page (\"form feed\"), rarely used In our files we only use SP and LF for whitespace. Irrelevant special characters are ommitted from the table.","title":"ASCII"},{"location":"reference/ascii/#ascii","text":"Each ASCII character corresponds to a byte in the range 0-127 (hex 0-7F). Rows correspond to the first hex digit, colums to the second hex digit. 0 1 2 3 4 5 6 7 8 9 A B C D E F 0 HT LF VT FF CR 1 2 SP ! \" # $ % & ' ( ) * + , - . / 3 0 1 2 3 4 5 6 7 8 9 : ; < = > ? 4 @ A B C D E F G H I J K L M N O 5 P Q R S T U V W X Y Z [ \\ ] ^ _ 6 ` a b c d e f g h i j k l m n o 7 p q r s t u v w x y z { | } ~ Whitespace characters: * SP: space * LF: end of line (\"line feed\") * HT: tab (\"horizontal tab\") * CR: alternate end of line (\"carriage return\"). Windows editors commonly end lines with two characters: CR LF. * VT: vertical tab, rarely used * FF: end of page (\"form feed\"), rarely used In our files we only use SP and LF for whitespace. Irrelevant special characters are ommitted from the table.","title":"ASCII"},{"location":"reference/elf/","text":"Linux executable files Executable files on Linux follow the ELF file format. The ELF format can store many different kinds of files for different CPUs and operating systems, but we are only interested in executable programs for x86 Linux. ELF Header An ELF file starts with a #34-byte (52-byte) the ELF Header: offset length contents comment #0 4 $7f 'E 'L 'F magic number that identifies ELF files #4 1 1 word size: 1 = 32-bit, 2 = 64-bit #5 1 1 endianness: 1 = little-endian, 2 = big-endian #6 1 1 ELF specification version #7 1 0 operating system ABI: 0 = UNIX System V (this is what is typically used) #8 1 0 operating system ABI version #9 7 0 0 0 0 0 0 0 padding #10 2 2 0 object file type: 2 = executable file #12 2 3 0 CPU: 3 = x86 #14 4 #1 ELF specification version 1 (same as #6) #18 4 program entry point (virtual address) #1c 4 #34 program header table location: #34 = directly behind the ELF header #20 4 #0 section header table location: 0 = none; executable files don't need sections #24 4 #0 flags (none are defined for Linux executables) #28 2 $34 0 ELF header size #2a 2 $20 0 program header size #2c 2 number of program headers #2e 2 0 0 section header size (ignored if there are no sections) #30 2 0 0 number of section headers (executable files don't need sections) #32 2 0 0 section name string table index: 0 = none Program header An ELF file contains a number of segments that will be loaded into memory. Those are described by the Program Header Table with some number of #20-byte (32-byte) Program Headers: offset length contents comment #0 4 #1 Segment type. 1 = load into memory #4 4 file location of the segment #8 4 virtual address; typically should be at least #10000 (64KB) #c 4 #0 physical address (ignored) #10 4 size in the file #14 4 size in memory; if larger than the size in the file, the rest is filled with 0 bytes #18 4 permissions (can be combined): #1 = execute, #2 = write, #4 = read #1c 4 #1000 memory alignment: one page = 4 KB The virtual address where a segment is loaded in memory must match its location in the file modulo memory page size (#1000) because that allows mapping the file into memory using the virtual memory system which works at page size granularity. Stack segment The stack segment is automatically created (normally at the top of memory addresses) for each executable program.","title":"Linux executable files"},{"location":"reference/elf/#linux-executable-files","text":"Executable files on Linux follow the ELF file format. The ELF format can store many different kinds of files for different CPUs and operating systems, but we are only interested in executable programs for x86 Linux.","title":"Linux executable files"},{"location":"reference/elf/#elf-header","text":"An ELF file starts with a #34-byte (52-byte) the ELF Header: offset length contents comment #0 4 $7f 'E 'L 'F magic number that identifies ELF files #4 1 1 word size: 1 = 32-bit, 2 = 64-bit #5 1 1 endianness: 1 = little-endian, 2 = big-endian #6 1 1 ELF specification version #7 1 0 operating system ABI: 0 = UNIX System V (this is what is typically used) #8 1 0 operating system ABI version #9 7 0 0 0 0 0 0 0 padding #10 2 2 0 object file type: 2 = executable file #12 2 3 0 CPU: 3 = x86 #14 4 #1 ELF specification version 1 (same as #6) #18 4 program entry point (virtual address) #1c 4 #34 program header table location: #34 = directly behind the ELF header #20 4 #0 section header table location: 0 = none; executable files don't need sections #24 4 #0 flags (none are defined for Linux executables) #28 2 $34 0 ELF header size #2a 2 $20 0 program header size #2c 2 number of program headers #2e 2 0 0 section header size (ignored if there are no sections) #30 2 0 0 number of section headers (executable files don't need sections) #32 2 0 0 section name string table index: 0 = none","title":"ELF Header"},{"location":"reference/elf/#program-header","text":"An ELF file contains a number of segments that will be loaded into memory. Those are described by the Program Header Table with some number of #20-byte (32-byte) Program Headers: offset length contents comment #0 4 #1 Segment type. 1 = load into memory #4 4 file location of the segment #8 4 virtual address; typically should be at least #10000 (64KB) #c 4 #0 physical address (ignored) #10 4 size in the file #14 4 size in memory; if larger than the size in the file, the rest is filled with 0 bytes #18 4 permissions (can be combined): #1 = execute, #2 = write, #4 = read #1c 4 #1000 memory alignment: one page = 4 KB The virtual address where a segment is loaded in memory must match its location in the file modulo memory page size (#1000) because that allows mapping the file into memory using the virtual memory system which works at page size granularity.","title":"Program header"},{"location":"reference/elf/#stack-segment","text":"The stack segment is automatically created (normally at the top of memory addresses) for each executable program.","title":"Stack segment"},{"location":"reference/syscalls/","text":"Linux system calls We write our code for Linux under 32-bit mode. Nowadays everybody has 64-bit computers, but 32-bit mode programs are supported under 64-bit Linuxes, so we use that. To call an operating system kernel service we use \"system calls\". Under 32-bit Linux these are entered via the int $80 (interrupt 128, or 80 in hexadecimal) machine code instruction. Parameters are put in registers (eax, ebx, ...), and the return value is returned in the eax register. The system calls we need are: name description eax ebx ecx edx return value exit exit the program 1 program return code none read read from a file 3 file descriptor buffer address buffer size number of bytes read write write to a file 4 file descriptor data address data length number of bytes written brk allocate memory 45 memory limit request new memory limit exit never returns. The program return code is a 1-byte code returned to the operating system. In bash it can be inspected using the $? special variable. 0 represents a normal exit, non-zero values represent failures. read reads up to buffer size bytes into the provided buffer from a file descriptor. File descriptor 0 is the standard input. Fewer bytes may be read than requested (but always at least 1, except on errors and end of file). 0 indicates end of file, -1 indicates an error. write writes up to data length bytes into a file descriptor. File descriptor 1 is the standard output, file descriptor 2 is the standard error stream. Fewer bytes may be written than requested (but always at least 1, except on errors). -1 indicates an error. brk changes the size of heap memory. We may ask to have memory allocated up to some limit, and the actual allocation is returned (it may be smaller if our request can't be satisfied). We can find out the initial address of (initially empty) heap memory by calling brk(0) .","title":"Linux system calls"},{"location":"reference/syscalls/#linux-system-calls","text":"We write our code for Linux under 32-bit mode. Nowadays everybody has 64-bit computers, but 32-bit mode programs are supported under 64-bit Linuxes, so we use that. To call an operating system kernel service we use \"system calls\". Under 32-bit Linux these are entered via the int $80 (interrupt 128, or 80 in hexadecimal) machine code instruction. Parameters are put in registers (eax, ebx, ...), and the return value is returned in the eax register. The system calls we need are: name description eax ebx ecx edx return value exit exit the program 1 program return code none read read from a file 3 file descriptor buffer address buffer size number of bytes read write write to a file 4 file descriptor data address data length number of bytes written brk allocate memory 45 memory limit request new memory limit exit never returns. The program return code is a 1-byte code returned to the operating system. In bash it can be inspected using the $? special variable. 0 represents a normal exit, non-zero values represent failures. read reads up to buffer size bytes into the provided buffer from a file descriptor. File descriptor 0 is the standard input. Fewer bytes may be read than requested (but always at least 1, except on errors and end of file). 0 indicates end of file, -1 indicates an error. write writes up to data length bytes into a file descriptor. File descriptor 1 is the standard output, file descriptor 2 is the standard error stream. Fewer bytes may be written than requested (but always at least 1, except on errors). -1 indicates an error. brk changes the size of heap memory. We may ask to have memory allocated up to some limit, and the actual allocation is returned (it may be smaller if our request can't be satisfied). We can find out the initial address of (initially empty) heap memory by calling brk(0) .","title":"Linux system calls"},{"location":"reference/x86/","text":"x86 machine code Hello x86","title":"x86 machine code"},{"location":"reference/x86/#x86-machine-code","text":"Hello x86","title":"x86 machine code"},{"location":"steps/first-program/","text":"First program Let's create our first executable program. It will print \"Hello, world!\" to the console. But where do we start? We assume that don't have a Python interpreter, a C++ compiler, or even an assembler available (or don't want to trust them!). Outline Assembly code Let start by writing the code in assembly: File layout file offset virtual address bytes assembly comment #0 ELF header: #0 $7f 'E' 'L' 'F' magic number: ELF file #4 1 EI_CLASS = ELFCLASS32 : 32-bit code #5 1 EI_DATA = ELFDATA2LSB : little-endian #6 1 EI_VERSION = EV_CURRENT : ELF version 1 #7 0 EI_OSABI = ELFOSABI_SYSV : UNIX System V ABI #8 0 EI_ABIVERSION = 0: UNIX System V ABI version #9 0 0 0 0 0 0 0 padding #10 2 0 e_type = ET_EXEC : executable file #12 3 0 e_machine = EM_386 : Intel 80386 CPU #14 #1 e_version = EV_CURRENT : ELF version 1 #18 #100054 start e_entry : program entry point #1c #34 e_phoff : program header table #20 #0 e_shoff : section header table offset (none) #24 #0 e_flags (none) #28 $34 0 e_ehsize : ELF header size #2a $20 0 e_phentsize : program header size #2c 1 0 e_phnum : number of program headers #2e 0 0 e_shentsize : section header size #30 0 0 e_shnum : number of section headers #32 0 0 e_shstrndx : section name string table index (none) ---- ------- --------------- --------------- --------------------- #34 program header: text segment #34 #1 p_type = PT_LOAD : load into memory #38 #54 p_offset : file offset of text segment #3c #100054 text p_vaddr : virtual address of text segment #40 #0 p_paddr : physical address (ignored) #44 #34 text_end - text p_filesz : file size of text segment #48 #34 text_end - text p_memsz : memory size of text segment #4c #7 p_flags : permissions, execute + write + read #50 #1000 p_align : alignment (page size, 4KB) ---- ------- --------------- --------------- --------------------- #54 #100054 text: start of executable code #54 #100054 start: first instruction executed #54 #100054 %273 #1 mov ebx, 1 ebx = standard output #59 #100059 %271 #10007a mov ecx, message ecx = message address #5e #10005e %272 #e mov edx, message_end - message edx = message length #63 #100063 write_loop: #63 #100063 %270 #4 mov eax, 4 eax = write system call #68 #100068 %315 $80 int $80 system call #6a #10006a %205 %300 test eax, eax check write error #6c #10006c $7e $6 jle exit exit if write error #6e #10006e %001 %301 add ecx, eax move string pointer #70 #100070 %051 %302 sub edx, eax decrease string length #72 #100072 $75 $ef jnz write_loop go back if any string remaining #74 #100074 exit: #74 #100074 %211 %330 mov eax, ebx eax = 1 = exit system call #76 #100076 %061 %333 xor ebx, ebx ebx = exit code 0 #78 #100078 %315 $80 int $80 system call #7a #10007a message: start of message #7a #10007a \"Hello, world!\" $a db \"Hello, world!\", $a the message with a new line #88 #100088 message\\_end: end of message #88 #100088 text\\_end: end of executable code Create the file!","title":"First program"},{"location":"steps/first-program/#first-program","text":"Let's create our first executable program. It will print \"Hello, world!\" to the console. But where do we start? We assume that don't have a Python interpreter, a C++ compiler, or even an assembler available (or don't want to trust them!).","title":"First program"},{"location":"steps/first-program/#outline","text":"","title":"Outline"},{"location":"steps/first-program/#assembly-code","text":"Let start by writing the code in assembly:","title":"Assembly code"},{"location":"steps/first-program/#file-layout","text":"file offset virtual address bytes assembly comment #0 ELF header: #0 $7f 'E' 'L' 'F' magic number: ELF file #4 1 EI_CLASS = ELFCLASS32 : 32-bit code #5 1 EI_DATA = ELFDATA2LSB : little-endian #6 1 EI_VERSION = EV_CURRENT : ELF version 1 #7 0 EI_OSABI = ELFOSABI_SYSV : UNIX System V ABI #8 0 EI_ABIVERSION = 0: UNIX System V ABI version #9 0 0 0 0 0 0 0 padding #10 2 0 e_type = ET_EXEC : executable file #12 3 0 e_machine = EM_386 : Intel 80386 CPU #14 #1 e_version = EV_CURRENT : ELF version 1 #18 #100054 start e_entry : program entry point #1c #34 e_phoff : program header table #20 #0 e_shoff : section header table offset (none) #24 #0 e_flags (none) #28 $34 0 e_ehsize : ELF header size #2a $20 0 e_phentsize : program header size #2c 1 0 e_phnum : number of program headers #2e 0 0 e_shentsize : section header size #30 0 0 e_shnum : number of section headers #32 0 0 e_shstrndx : section name string table index (none) ---- ------- --------------- --------------- --------------------- #34 program header: text segment #34 #1 p_type = PT_LOAD : load into memory #38 #54 p_offset : file offset of text segment #3c #100054 text p_vaddr : virtual address of text segment #40 #0 p_paddr : physical address (ignored) #44 #34 text_end - text p_filesz : file size of text segment #48 #34 text_end - text p_memsz : memory size of text segment #4c #7 p_flags : permissions, execute + write + read #50 #1000 p_align : alignment (page size, 4KB) ---- ------- --------------- --------------- --------------------- #54 #100054 text: start of executable code #54 #100054 start: first instruction executed #54 #100054 %273 #1 mov ebx, 1 ebx = standard output #59 #100059 %271 #10007a mov ecx, message ecx = message address #5e #10005e %272 #e mov edx, message_end - message edx = message length #63 #100063 write_loop: #63 #100063 %270 #4 mov eax, 4 eax = write system call #68 #100068 %315 $80 int $80 system call #6a #10006a %205 %300 test eax, eax check write error #6c #10006c $7e $6 jle exit exit if write error #6e #10006e %001 %301 add ecx, eax move string pointer #70 #100070 %051 %302 sub edx, eax decrease string length #72 #100072 $75 $ef jnz write_loop go back if any string remaining #74 #100074 exit: #74 #100074 %211 %330 mov eax, ebx eax = 1 = exit system call #76 #100076 %061 %333 xor ebx, ebx ebx = exit code 0 #78 #100078 %315 $80 int $80 system call #7a #10007a message: start of message #7a #10007a \"Hello, world!\" $a db \"Hello, world!\", $a the message with a new line #88 #100088 message\\_end: end of message #88 #100088 text\\_end: end of executable code","title":"File layout"},{"location":"steps/first-program/#create-the-file","text":"","title":"Create the file!"}]}