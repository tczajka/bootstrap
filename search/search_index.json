{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bootstrapping a compiler We are going to bootstrap a compiler for a high level programming language without using another programming language. Not even assembly. We are going to build our tools from scratch! Before we get there, it will take a lot of little steps. And we will learn a lot in the process. Where do we start? We assume we have a computer with a Linux operating system and a terminal running bash . We will use some basic Linux command line utilities such as echo and cat and a text editor such as vi, emacs or gedit. We could make do even without these tools and build our own operating system and a text editor from scratch. But we'll not tie our hands that much. Maybe some day. We will build our tools in phases: We have to start somewhere. Our first programs will be built from the command line using echo . Octal . This will let us write code as a sequence of numbers in octal (base 8) in a text file and get them translated to a binary file. Why base 8? It is simple to parse, and x86 machine code opcodes are easiest to understand in base 8. Bytes . This will make our lifes somewhat easier. It will allow us to use octal and hexadecimal, comments, and refer to addresses by labels. Stack . A stack-based programming language inspired by Forth. Brooklyn . A programming language similar to C or Pascal. Tetris . The game. All the code is available in the src directory of the github repository. The Makefile has all the build steps. So if you want to see a program in action rather than repeat the whole process yourself, you can build any step in the tutorial using make : $ make bin/hello.1 [...] $ bin/hello.1 Hello, world!","title":"Home"},{"location":"#bootstrapping-a-compiler","text":"We are going to bootstrap a compiler for a high level programming language without using another programming language. Not even assembly. We are going to build our tools from scratch! Before we get there, it will take a lot of little steps. And we will learn a lot in the process. Where do we start? We assume we have a computer with a Linux operating system and a terminal running bash . We will use some basic Linux command line utilities such as echo and cat and a text editor such as vi, emacs or gedit. We could make do even without these tools and build our own operating system and a text editor from scratch. But we'll not tie our hands that much. Maybe some day. We will build our tools in phases: We have to start somewhere. Our first programs will be built from the command line using echo . Octal . This will let us write code as a sequence of numbers in octal (base 8) in a text file and get them translated to a binary file. Why base 8? It is simple to parse, and x86 machine code opcodes are easiest to understand in base 8. Bytes . This will make our lifes somewhat easier. It will allow us to use octal and hexadecimal, comments, and refer to addresses by labels. Stack . A stack-based programming language inspired by Forth. Brooklyn . A programming language similar to C or Pascal. Tetris . The game. All the code is available in the src directory of the github repository. The Makefile has all the build steps. So if you want to see a program in action rather than repeat the whole process yourself, you can build any step in the tutorial using make : $ make bin/hello.1 [...] $ bin/hello.1 Hello, world!","title":"Bootstrapping a compiler"},{"location":"hello-world/","text":"Hello, world! Let's create our first executable program. It will print Hello, world! to the console. But where do we start? We assume that don't have a Python interpreter, a C++ compiler, or even an assembler available (or don't want to trust them!). Assembly code Despite the lack of an assembler, we start by writing code in assembly. We will then manually convert it to machine code. We want to call the write system call to print the message to the standard output of the process. The operating system automatically opens 3 files for each process: file descriptor 0: standard input file descriptor 1: standard output file descriptor 2: standard error text: ; beginning of text segment start: ; entry point to the program mov ebx, 1 ; ebx = standard output mov ecx, message ; ecx = message address mov edx, message_end - message ; edx = message length write_loop: mov eax, 4 ; eax = \"write\" system call int $80 ; system call The write system call can fail. For example, if we redirect the output to a file, and we run out of disk space, it will fail. It can also write only part of the message for various reasons. The return value in eax tells us what happened: -1 indicates failure a positive value indicates the number of bytes actually written So we need to check. On failure we will just finish the program. If a message has been printed partially, we will loop around and continue writing. That's why we have put the write_loop label in the code above. test eax, eax ; eax = bytes written by \"write\", or -1 if error jle exit ; exit on failure; ebx = exit code 1 add ecx, eax ; ecx = remaining message sub edx, eax ; edx = remaining length jnz write_loop ; if edx != 0, go back to write_loop Then we need to call the exit system call to finish the program. We will pass 0 in ebx to indicate a successful exit, and 1 to indicate an error. It just so happens that ebx already contains 1. exit_success: xor ebx, ebx ; ebx = 0 = successful exit exit: ; return value in ebx mov eax, 1 ; eax = \"exit\" system call int $80 ; system call Finally we need the message we want to print. db defines bytes, and we write the message in ASCII, including the \"new line\" character (ASCII $a ). Note: $ indicates a hexadecimal byte . message: db \"Hello, world!\", $0a ; the message with a new line message_end: ; end of the message text_end: ; end of text segment ELF header Our executable file needs to begin with an ELF header . According to our conventions , $ indicates a hexadecimal byte, # a hexadecimal 32-bit number, % an octal byte, ' an ASCII byte. offset contents comment #0 $7f 'E 'L 'F magic number that identifies ELF files #4 1 word size: 32-bit #5 1 endianness: little-endian #6 1 ELF specification version #7 0 operating system ABI: UNIX System V #8 0 operating system ABI version #9 0 0 0 #0 padding #10 2 0 object file type: executable file #12 3 0 CPU: x86 #14 #1 ELF specification version again #18 start program entry point (virtual address) #1c #34 program header table location (directly behind the ELF header) #20 #0 section header table location: none #24 #0 flags (none) #28 $34 0 ELF header size #2a $20 0 program header size #2c 1 0 number of program headers #2e 0 0 section header size (ignored) #30 0 0 number of section headers #32 0 0 section name string table index: none We will fill out the address of start later. Now we need the program header table describing memory segments: parts of the file that should be loaded into memory. Normally we want seperate segments for executable code, read-only data and read-write data, each with appropriate permissions. But for simplicity we define only one segment that contains both code and read-only data (the message). Traditionally the code segment is called text . offset contents comment #34 #1 segment type: load into memory #38 #54 location of the segment (immediately after the program header table) #3c text virtual address of the text segment #40 #0 physical address (ignored) #44 text_end - text file size of the text segment #48 text_end - text size in memory (same) #4c #1 + #4 permissions: execute + read #50 #1000 memory alignment, 4 KB We will need to fill out the address and length of the segment, later. We need to decide where in virtual memory our code will be stored. Linux won't typically let us just put things at virtual address 0. The file /proc/sys/vm/mmap_min_addr shows the minimum address: it's typically 64 KB = #10000 . It doesn't really matter much where we put it. Let's put it at #100000 (1 MB). But we can't quite use #100000 as the beginning of the segment because of page alignment. Since we will start at at #54 in the file, we have to start it at #100054 in virtual memory. This way Linux can map pages of the file (of size #1000 ) into virtual memory. And finally, we put the actual machine code in the file. We translate assembly instructions into x86 machine code . offset virtual address contents assembly #54 #100054 text: #54 #100054 start: #54 #100054 %273 #1 mov ebx, 1 #59 #100059 %271 message mov ecx, message #5e #10005e %272 message_end - message mov edx, message_end - message #63 #100063 write_loop: #63 #100063 %270 #4 mov eax, 4 #68 #100068 %315 $80 int $80 #6a #10006a %205 %300 test eax, eax #6c #10006c $7e exit - * jle exit #6e #10006e %003 %310 add ecx, eax #70 #100070 %053 %320 sub edx, eax #72 #100072 $75 write_loop - * jnz write_loop #74 #100074 exit_success: #76 #100074 %063 %333 xor ebx, ebx #76 #100076 exit: #76 #100076 %270 #1 mov eax, 1 #7b #10007b %315 $80 int $80 #7d #10007d message: #7d #10007d \"Hello, world!\" $a db \"Hello, world!\", $a #8b #10008b message_end: #8b #10008b text_end: Fill in addresses Now we need to fill in addresses into our headers and our code. Note that we used * to indicate \"next instruction\", needed for relative addressing. expr value start #100054 text #100054 text_end - text #37 message #10007d message_end - message #e exit - * $8 write_loop - * -$11 = $ef Create the file! Now that we know what #8b = 139 bytes we want to put in the file, let's put them in! We can use the bash echo command. -e enables escape codes: \\0ooo is an octal escape code, \\xhh is a hexadecimal escape code. -n means: don't add an extra new line at the end. We write the ! character in the message as its ASCII code \\x21 because ! a special character in bash strings. $ mkdir bin $ echo -en \"\\ > \\x7fELF\\x1\\x1\\x1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\x2\\0\\x3\\0\\x1\\0\\0\\0\\ > \\x54\\0\\x10\\0\\x34\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\x34\\0\\x20\\0\\x1\\0\\0\\0\\0\\0\\0\\0\\ > \\x1\\0\\0\\0\\x54\\0\\0\\0\\x54\\0\\x10\\0\\0\\0\\0\\0\\x37\\0\\0\\0\\x37\\0\\0\\0\\x5\\0\\0\\0\\x0\\x10\\0\\0\\ > \\0273\\x1\\0\\0\\0\\0271\\x7d\\0\\x10\\0\\0272\\xe\\0\\0\\0\\ > \\0270\\x4\\0\\0\\0\\\\0315\\x80\\0205\\0300\\x7e\\x8\\03\\0310\\053\\0320\\x75\\xef\\ > \\063\\0333\\0270\\x1\\0\\0\\0\\0315\\x80Hello, world\\x21\\xa\" > bin/hello.1 $ wc -l bin/hello.1 139 bin/hello.1 $ chmod u+x bin/hello.1 Let's try it! $ bin/hello.1 Hello, world! It works! We have created our first program from scratch.","title":"Hello, world!"},{"location":"hello-world/#hello-world","text":"Let's create our first executable program. It will print Hello, world! to the console. But where do we start? We assume that don't have a Python interpreter, a C++ compiler, or even an assembler available (or don't want to trust them!).","title":"Hello, world!"},{"location":"hello-world/#assembly-code","text":"Despite the lack of an assembler, we start by writing code in assembly. We will then manually convert it to machine code. We want to call the write system call to print the message to the standard output of the process. The operating system automatically opens 3 files for each process: file descriptor 0: standard input file descriptor 1: standard output file descriptor 2: standard error text: ; beginning of text segment start: ; entry point to the program mov ebx, 1 ; ebx = standard output mov ecx, message ; ecx = message address mov edx, message_end - message ; edx = message length write_loop: mov eax, 4 ; eax = \"write\" system call int $80 ; system call The write system call can fail. For example, if we redirect the output to a file, and we run out of disk space, it will fail. It can also write only part of the message for various reasons. The return value in eax tells us what happened: -1 indicates failure a positive value indicates the number of bytes actually written So we need to check. On failure we will just finish the program. If a message has been printed partially, we will loop around and continue writing. That's why we have put the write_loop label in the code above. test eax, eax ; eax = bytes written by \"write\", or -1 if error jle exit ; exit on failure; ebx = exit code 1 add ecx, eax ; ecx = remaining message sub edx, eax ; edx = remaining length jnz write_loop ; if edx != 0, go back to write_loop Then we need to call the exit system call to finish the program. We will pass 0 in ebx to indicate a successful exit, and 1 to indicate an error. It just so happens that ebx already contains 1. exit_success: xor ebx, ebx ; ebx = 0 = successful exit exit: ; return value in ebx mov eax, 1 ; eax = \"exit\" system call int $80 ; system call Finally we need the message we want to print. db defines bytes, and we write the message in ASCII, including the \"new line\" character (ASCII $a ). Note: $ indicates a hexadecimal byte . message: db \"Hello, world!\", $0a ; the message with a new line message_end: ; end of the message text_end: ; end of text segment","title":"Assembly code"},{"location":"hello-world/#elf-header","text":"Our executable file needs to begin with an ELF header . According to our conventions , $ indicates a hexadecimal byte, # a hexadecimal 32-bit number, % an octal byte, ' an ASCII byte. offset contents comment #0 $7f 'E 'L 'F magic number that identifies ELF files #4 1 word size: 32-bit #5 1 endianness: little-endian #6 1 ELF specification version #7 0 operating system ABI: UNIX System V #8 0 operating system ABI version #9 0 0 0 #0 padding #10 2 0 object file type: executable file #12 3 0 CPU: x86 #14 #1 ELF specification version again #18 start program entry point (virtual address) #1c #34 program header table location (directly behind the ELF header) #20 #0 section header table location: none #24 #0 flags (none) #28 $34 0 ELF header size #2a $20 0 program header size #2c 1 0 number of program headers #2e 0 0 section header size (ignored) #30 0 0 number of section headers #32 0 0 section name string table index: none We will fill out the address of start later. Now we need the program header table describing memory segments: parts of the file that should be loaded into memory. Normally we want seperate segments for executable code, read-only data and read-write data, each with appropriate permissions. But for simplicity we define only one segment that contains both code and read-only data (the message). Traditionally the code segment is called text . offset contents comment #34 #1 segment type: load into memory #38 #54 location of the segment (immediately after the program header table) #3c text virtual address of the text segment #40 #0 physical address (ignored) #44 text_end - text file size of the text segment #48 text_end - text size in memory (same) #4c #1 + #4 permissions: execute + read #50 #1000 memory alignment, 4 KB We will need to fill out the address and length of the segment, later. We need to decide where in virtual memory our code will be stored. Linux won't typically let us just put things at virtual address 0. The file /proc/sys/vm/mmap_min_addr shows the minimum address: it's typically 64 KB = #10000 . It doesn't really matter much where we put it. Let's put it at #100000 (1 MB). But we can't quite use #100000 as the beginning of the segment because of page alignment. Since we will start at at #54 in the file, we have to start it at #100054 in virtual memory. This way Linux can map pages of the file (of size #1000 ) into virtual memory. And finally, we put the actual machine code in the file. We translate assembly instructions into x86 machine code . offset virtual address contents assembly #54 #100054 text: #54 #100054 start: #54 #100054 %273 #1 mov ebx, 1 #59 #100059 %271 message mov ecx, message #5e #10005e %272 message_end - message mov edx, message_end - message #63 #100063 write_loop: #63 #100063 %270 #4 mov eax, 4 #68 #100068 %315 $80 int $80 #6a #10006a %205 %300 test eax, eax #6c #10006c $7e exit - * jle exit #6e #10006e %003 %310 add ecx, eax #70 #100070 %053 %320 sub edx, eax #72 #100072 $75 write_loop - * jnz write_loop #74 #100074 exit_success: #76 #100074 %063 %333 xor ebx, ebx #76 #100076 exit: #76 #100076 %270 #1 mov eax, 1 #7b #10007b %315 $80 int $80 #7d #10007d message: #7d #10007d \"Hello, world!\" $a db \"Hello, world!\", $a #8b #10008b message_end: #8b #10008b text_end:","title":"ELF header"},{"location":"hello-world/#fill-in-addresses","text":"Now we need to fill in addresses into our headers and our code. Note that we used * to indicate \"next instruction\", needed for relative addressing. expr value start #100054 text #100054 text_end - text #37 message #10007d message_end - message #e exit - * $8 write_loop - * -$11 = $ef","title":"Fill in addresses"},{"location":"hello-world/#create-the-file","text":"Now that we know what #8b = 139 bytes we want to put in the file, let's put them in! We can use the bash echo command. -e enables escape codes: \\0ooo is an octal escape code, \\xhh is a hexadecimal escape code. -n means: don't add an extra new line at the end. We write the ! character in the message as its ASCII code \\x21 because ! a special character in bash strings. $ mkdir bin $ echo -en \"\\ > \\x7fELF\\x1\\x1\\x1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\x2\\0\\x3\\0\\x1\\0\\0\\0\\ > \\x54\\0\\x10\\0\\x34\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\x34\\0\\x20\\0\\x1\\0\\0\\0\\0\\0\\0\\0\\ > \\x1\\0\\0\\0\\x54\\0\\0\\0\\x54\\0\\x10\\0\\0\\0\\0\\0\\x37\\0\\0\\0\\x37\\0\\0\\0\\x5\\0\\0\\0\\x0\\x10\\0\\0\\ > \\0273\\x1\\0\\0\\0\\0271\\x7d\\0\\x10\\0\\0272\\xe\\0\\0\\0\\ > \\0270\\x4\\0\\0\\0\\\\0315\\x80\\0205\\0300\\x7e\\x8\\03\\0310\\053\\0320\\x75\\xef\\ > \\063\\0333\\0270\\x1\\0\\0\\0\\0315\\x80Hello, world\\x21\\xa\" > bin/hello.1 $ wc -l bin/hello.1 139 bin/hello.1 $ chmod u+x bin/hello.1 Let's try it! $ bin/hello.1 Hello, world! It works! We have created our first program from scratch.","title":"Create the file!"},{"location":"reference/ascii/","text":"ASCII Each ASCII character corresponds to a byte in the range 0-127 (hex 0- $7F ). Rows correspond to the first hex digit, colums to the second hex digit. 0 1 2 3 4 5 6 7 8 9 A B C D E F 0 HT LF VT FF CR 1 2 SP ! \" # $ % & ' ( ) * + , - . / 3 0 1 2 3 4 5 6 7 8 9 : ; < = > ? 4 @ A B C D E F G H I J K L M N O 5 P Q R S T U V W X Y Z [ \\ ] ^ _ 6 ` a b c d e f g h i j k l m n o 7 p q r s t u v w x y z { | } ~ Whitespace characters: SP : space LF : end of line (\"line feed\") HT : tab (\"horizontal tab\") CR : alternate end of line (\"carriage return\"). Windows editors commonly end lines with two characters: CR LF. VT : vertical tab, rarely used FF : end of page (\"form feed\"), rarely used In our files we only use SP and LF for whitespace. Irrelevant special characters are ommitted from the table.","title":"ASCII"},{"location":"reference/ascii/#ascii","text":"Each ASCII character corresponds to a byte in the range 0-127 (hex 0- $7F ). Rows correspond to the first hex digit, colums to the second hex digit. 0 1 2 3 4 5 6 7 8 9 A B C D E F 0 HT LF VT FF CR 1 2 SP ! \" # $ % & ' ( ) * + , - . / 3 0 1 2 3 4 5 6 7 8 9 : ; < = > ? 4 @ A B C D E F G H I J K L M N O 5 P Q R S T U V W X Y Z [ \\ ] ^ _ 6 ` a b c d e f g h i j k l m n o 7 p q r s t u v w x y z { | } ~ Whitespace characters: SP : space LF : end of line (\"line feed\") HT : tab (\"horizontal tab\") CR : alternate end of line (\"carriage return\"). Windows editors commonly end lines with two characters: CR LF. VT : vertical tab, rarely used FF : end of page (\"form feed\"), rarely used In our files we only use SP and LF for whitespace. Irrelevant special characters are ommitted from the table.","title":"ASCII"},{"location":"reference/elf/","text":"Linux executable files Executable files on Linux follow the ELF file format. The ELF format can store many different kinds of files for different CPUs and operating systems, but we are only interested in executable programs for x86 Linux. ELF Header An ELF file starts with a #34 -byte (52-byte) the ELF Header: offset length contents comment #0 4 $7f 'E 'L 'F magic number that identifies ELF files #4 1 1 word size: 1 = 32-bit, 2 = 64-bit #5 1 1 endianness: 1 = little-endian, 2 = big-endian #6 1 1 ELF specification version #7 1 0 operating system ABI: 0 = UNIX System V (this is what is typically used) #8 1 0 operating system ABI version #9 7 0 0 0 0 0 0 0 padding #10 2 2 0 object file type: 2 = executable file #12 2 3 0 CPU: 3 = x86 #14 4 #1 ELF specification version 1 (same as entry at #6 ) #18 4 program entry point (virtual address) #1c 4 #34 program header table location: #34 = directly behind the ELF header #20 4 #0 section header table location: 0 = none; executable files don't need sections #24 4 #0 flags (none are defined for Linux executables) #28 2 $34 0 ELF header size #2a 2 $20 0 program header size #2c 2 number of program headers #2e 2 0 0 section header size (ignored if there are no sections) #30 2 0 0 number of section headers (executable files don't need sections) #32 2 0 0 section name string table index: 0 = none Program header An ELF file contains a number of segments that will be loaded into memory. Those are described by the Program Header Table with some number of #20 -byte (32-byte) Program Headers: offset length contents comment #0 4 #1 Segment type. 1 = load into memory #4 4 file location of the segment #8 4 virtual address; typically should be at least #10000 (64KB) #c 4 #0 physical address (ignored) #10 4 size in the file #14 4 size in memory; if larger than the size in the file, the rest is filled with 0 bytes #18 4 permissions (can be combined): #1 = execute, #2 = write, #4 = read #1c 4 #1000 memory alignment: one page = 4 KB The virtual address where a segment is loaded in memory must match its location in the file modulo memory page size ( #1000 ) because that allows mapping the file into memory using the virtual memory system which works at page size granularity. Stack segment The stack segment is automatically created (normally at the top of memory addresses) for each executable program.","title":"Linux executable files"},{"location":"reference/elf/#linux-executable-files","text":"Executable files on Linux follow the ELF file format. The ELF format can store many different kinds of files for different CPUs and operating systems, but we are only interested in executable programs for x86 Linux.","title":"Linux executable files"},{"location":"reference/elf/#elf-header","text":"An ELF file starts with a #34 -byte (52-byte) the ELF Header: offset length contents comment #0 4 $7f 'E 'L 'F magic number that identifies ELF files #4 1 1 word size: 1 = 32-bit, 2 = 64-bit #5 1 1 endianness: 1 = little-endian, 2 = big-endian #6 1 1 ELF specification version #7 1 0 operating system ABI: 0 = UNIX System V (this is what is typically used) #8 1 0 operating system ABI version #9 7 0 0 0 0 0 0 0 padding #10 2 2 0 object file type: 2 = executable file #12 2 3 0 CPU: 3 = x86 #14 4 #1 ELF specification version 1 (same as entry at #6 ) #18 4 program entry point (virtual address) #1c 4 #34 program header table location: #34 = directly behind the ELF header #20 4 #0 section header table location: 0 = none; executable files don't need sections #24 4 #0 flags (none are defined for Linux executables) #28 2 $34 0 ELF header size #2a 2 $20 0 program header size #2c 2 number of program headers #2e 2 0 0 section header size (ignored if there are no sections) #30 2 0 0 number of section headers (executable files don't need sections) #32 2 0 0 section name string table index: 0 = none","title":"ELF Header"},{"location":"reference/elf/#program-header","text":"An ELF file contains a number of segments that will be loaded into memory. Those are described by the Program Header Table with some number of #20 -byte (32-byte) Program Headers: offset length contents comment #0 4 #1 Segment type. 1 = load into memory #4 4 file location of the segment #8 4 virtual address; typically should be at least #10000 (64KB) #c 4 #0 physical address (ignored) #10 4 size in the file #14 4 size in memory; if larger than the size in the file, the rest is filled with 0 bytes #18 4 permissions (can be combined): #1 = execute, #2 = write, #4 = read #1c 4 #1000 memory alignment: one page = 4 KB The virtual address where a segment is loaded in memory must match its location in the file modulo memory page size ( #1000 ) because that allows mapping the file into memory using the virtual memory system which works at page size granularity.","title":"Program header"},{"location":"reference/elf/#stack-segment","text":"The stack segment is automatically created (normally at the top of memory addresses) for each executable program.","title":"Stack segment"},{"location":"reference/numbers/","text":"Number notation We write numbers as follows: prefix base bytes notes none 10 We use base 10 informally. % 8 1 Octal bytes are prefixed by % . $ 16 1 Hexadecimal bytes are prefixed by $ . # 16 4 Hexadecimal 32-bit numbers are prefixed by # . ' 256 1 ASCII character. For example: 65 = $41 = %101 = 'A .","title":"Number notation"},{"location":"reference/numbers/#number-notation","text":"We write numbers as follows: prefix base bytes notes none 10 We use base 10 informally. % 8 1 Octal bytes are prefixed by % . $ 16 1 Hexadecimal bytes are prefixed by $ . # 16 4 Hexadecimal 32-bit numbers are prefixed by # . ' 256 1 ASCII character. For example: 65 = $41 = %101 = 'A .","title":"Number notation"},{"location":"reference/syscalls/","text":"Linux system calls We write our code for Linux under 32-bit mode. Nowadays everybody has 64-bit computers, but 32-bit mode programs are supported under 64-bit Linuxes, so we use that. To call an operating system kernel service we use \"system calls\". Under 32-bit Linux these are entered via the int $80 (interrupt 128, or $80 in hexadecimal) machine code instruction. Parameters are put in registers (eax, ebx, ...), and the return value is returned in the eax register. The system calls we need are: name description eax ebx ecx edx return value exit exit the program 1 program return code none read read from a file 3 file descriptor buffer address buffer size number of bytes read write write to a file 4 file descriptor data address data length number of bytes written brk allocate memory 45 memory limit request new memory limit exit never returns. The program return code is a 1-byte code returned to the operating system. In bash it can be inspected using the $? special variable. 0 represents a normal exit, non-zero values represent failures. read reads up to buffer size bytes into the provided buffer from a file descriptor. File descriptor 0 is the standard input. Fewer bytes may be read than requested (but always at least 1, except on errors and end of file). 0 indicates end of file, -1 indicates an error. write writes up to data length bytes into a file descriptor. File descriptor 1 is the standard output, file descriptor 2 is the standard error stream. Fewer bytes may be written than requested (but always at least 1, except on errors). -1 indicates an error. brk changes the size of heap memory. We may ask to have memory allocated up to some limit, and the actual allocation is returned (it may be smaller if our request can't be satisfied). We can find out the initial address of (initially empty) heap memory by calling brk(0) .","title":"Linux system calls"},{"location":"reference/syscalls/#linux-system-calls","text":"We write our code for Linux under 32-bit mode. Nowadays everybody has 64-bit computers, but 32-bit mode programs are supported under 64-bit Linuxes, so we use that. To call an operating system kernel service we use \"system calls\". Under 32-bit Linux these are entered via the int $80 (interrupt 128, or $80 in hexadecimal) machine code instruction. Parameters are put in registers (eax, ebx, ...), and the return value is returned in the eax register. The system calls we need are: name description eax ebx ecx edx return value exit exit the program 1 program return code none read read from a file 3 file descriptor buffer address buffer size number of bytes read write write to a file 4 file descriptor data address data length number of bytes written brk allocate memory 45 memory limit request new memory limit exit never returns. The program return code is a 1-byte code returned to the operating system. In bash it can be inspected using the $? special variable. 0 represents a normal exit, non-zero values represent failures. read reads up to buffer size bytes into the provided buffer from a file descriptor. File descriptor 0 is the standard input. Fewer bytes may be read than requested (but always at least 1, except on errors and end of file). 0 indicates end of file, -1 indicates an error. write writes up to data length bytes into a file descriptor. File descriptor 1 is the standard output, file descriptor 2 is the standard error stream. Fewer bytes may be written than requested (but always at least 1, except on errors). -1 indicates an error. brk changes the size of heap memory. We may ask to have memory allocated up to some limit, and the actual allocation is returned (it may be smaller if our request can't be satisfied). We can find out the initial address of (initially empty) heap memory by calling brk(0) .","title":"Linux system calls"},{"location":"reference/x86/","text":"x86 machine code We write all our code for x86 CPUs in 32-bit mode. This is the \"protected mode\" on 32-bit operating systems or \"compatibility mode\" on 64-bit operating systems. We only describe some common instructions that may be useful to us. Registers There are 8 general-purpose 32-bit registers: ID name special uses 0 eax some arithmetic instructions use it implicitly 1 ecx 2 edx 3 ebx 4 esp stack pointer (stack grows down) 5 ebp 6 esi 7 edi 8-bit instructions use 8-bit fragments of these registers ID name which byte 0 al lowest byte of eax 1 cl lowest byte of ecx 2 dl lowest byte of edx 3 bl lowest byte of ebx 4 ah second-lowest byte of eax 5 ch second-lowest byte of ecx 6 dh second-lowest byte of edx 7 bh second-lowest byte of ebx Moves Move instructions copy data between registers and/or memory. Note that we use %, $, # to indicate octal and hexadecimal numbers . machine code assembly description %212 %3xy movb x, y 8-bit copy %213 %3xy mov x, y 32-bit copy %212 %0xy movb x, [y] 8-bit load from memory %213 %0xy mov x, [y] 32-bit load from memory %210 %0xy movb [y], x 8-bit store in memory %211 %0xy mov [y], x 32-bit store in memory %26x $y movb x, $y 8-bit load constant %27x #y mov x, #y 32-bit load constant Basic arithmetic and logic Basic arithmetic instructions are encoded similarly to moves: machine code assembly description %0p2 %3xy opb x, y 8-bit arithmetic %0p3 %3xy op x, y 32-bit arithmetic %0p0 %0xy opb [y], x 8-bit arithmetic to memory %0p1 %0xy op [y], x 32-bit arithmetic to memory %0p2 %0xy opb x, [y] 8-bit arithmetic from memory %0p3 %0xy opb x, [y] 32-bit arithmetic from memory %0p4 $y opb al, $y 8-bit arithmetic of al with a constant %0p5 #y op eax, #y 32-bit arithmetic of eax with a constant %200 %3px $y opb x, $y 8-bit arithmetic with a constant %201 %3px #y op x, #y 32-bit arithmetic with a constant %203 %3px $y op x, $y 32-bit arithmetic with a sign-extended 8-bit constant Where p is one of 8 basic arithmetic and logic operations: ID op description 0 add addition 1 or bitwise or 2 adc add with carry 3 sbb subtract with borrow 4 and bitwise and 5 sub subtraction 6 xor exclusive or 7 cmp compare ( sub without storing result) Other arithmetic machine code assembly description %10x inc x increment by 1 %11x dec x decrement by 1 %205 %3xy test x, y and x, y without storing the result %301 %34x $y shl x, $y shift x left by y bits %301 %35x $y shr x, $y signed shift x right by y bits %301 %37x $y sar x, $y unsigned shift x right by y bits Stack operations Pushing on the stack means decrementing esp by 4 and storing the value at [esp] . Popping off the stack is the opposite operation. Calling a function pushes the return address on the stack. Returning from the function pops it off the stack. machine code assembly description %12x push x push on the stack %13x pop x pop off the stack %350 #rel call #rel call function, rel : 32-bit relative address %303 ret return from a function Jumps machine code assembly description %377 $rel jmp $rel jump, rel : 8-bit relative address %351 #rel jmp #rel jump, rel : 32-bit relative address $7q $rel jq $rel conditional jump, q : condition, rel : 8-bit relative address Conditional jumps are easiest to write in hexadecimal. $7x corresponds to %16x or %17x in octal. Possible conditions are as follows: ID condition description 0 o signed overflow 1 no signed no overflow 2 c / b unsigned carry or < 3 nc / ae unsigned no carry or >= 4 e / z equal or zero 5 ne / nz not equal or not zero 6 be unsigned <= 7 a unsigned > 8 s signed < 0 9 ns signed >= 0 a p odd parity b np even parity c l signed < d ge signed >= e le signed <= f g signed > Software interrupts A system call is achieved by calling software interrupt $80 . machine code assembly description %315 $x int $x software interrupt number x","title":"x86 machine code"},{"location":"reference/x86/#x86-machine-code","text":"We write all our code for x86 CPUs in 32-bit mode. This is the \"protected mode\" on 32-bit operating systems or \"compatibility mode\" on 64-bit operating systems. We only describe some common instructions that may be useful to us.","title":"x86 machine code"},{"location":"reference/x86/#registers","text":"There are 8 general-purpose 32-bit registers: ID name special uses 0 eax some arithmetic instructions use it implicitly 1 ecx 2 edx 3 ebx 4 esp stack pointer (stack grows down) 5 ebp 6 esi 7 edi 8-bit instructions use 8-bit fragments of these registers ID name which byte 0 al lowest byte of eax 1 cl lowest byte of ecx 2 dl lowest byte of edx 3 bl lowest byte of ebx 4 ah second-lowest byte of eax 5 ch second-lowest byte of ecx 6 dh second-lowest byte of edx 7 bh second-lowest byte of ebx","title":"Registers"},{"location":"reference/x86/#moves","text":"Move instructions copy data between registers and/or memory. Note that we use %, $, # to indicate octal and hexadecimal numbers . machine code assembly description %212 %3xy movb x, y 8-bit copy %213 %3xy mov x, y 32-bit copy %212 %0xy movb x, [y] 8-bit load from memory %213 %0xy mov x, [y] 32-bit load from memory %210 %0xy movb [y], x 8-bit store in memory %211 %0xy mov [y], x 32-bit store in memory %26x $y movb x, $y 8-bit load constant %27x #y mov x, #y 32-bit load constant","title":"Moves"},{"location":"reference/x86/#basic-arithmetic-and-logic","text":"Basic arithmetic instructions are encoded similarly to moves: machine code assembly description %0p2 %3xy opb x, y 8-bit arithmetic %0p3 %3xy op x, y 32-bit arithmetic %0p0 %0xy opb [y], x 8-bit arithmetic to memory %0p1 %0xy op [y], x 32-bit arithmetic to memory %0p2 %0xy opb x, [y] 8-bit arithmetic from memory %0p3 %0xy opb x, [y] 32-bit arithmetic from memory %0p4 $y opb al, $y 8-bit arithmetic of al with a constant %0p5 #y op eax, #y 32-bit arithmetic of eax with a constant %200 %3px $y opb x, $y 8-bit arithmetic with a constant %201 %3px #y op x, #y 32-bit arithmetic with a constant %203 %3px $y op x, $y 32-bit arithmetic with a sign-extended 8-bit constant Where p is one of 8 basic arithmetic and logic operations: ID op description 0 add addition 1 or bitwise or 2 adc add with carry 3 sbb subtract with borrow 4 and bitwise and 5 sub subtraction 6 xor exclusive or 7 cmp compare ( sub without storing result)","title":"Basic arithmetic and logic"},{"location":"reference/x86/#other-arithmetic","text":"machine code assembly description %10x inc x increment by 1 %11x dec x decrement by 1 %205 %3xy test x, y and x, y without storing the result %301 %34x $y shl x, $y shift x left by y bits %301 %35x $y shr x, $y signed shift x right by y bits %301 %37x $y sar x, $y unsigned shift x right by y bits","title":"Other arithmetic"},{"location":"reference/x86/#stack-operations","text":"Pushing on the stack means decrementing esp by 4 and storing the value at [esp] . Popping off the stack is the opposite operation. Calling a function pushes the return address on the stack. Returning from the function pops it off the stack. machine code assembly description %12x push x push on the stack %13x pop x pop off the stack %350 #rel call #rel call function, rel : 32-bit relative address %303 ret return from a function","title":"Stack operations"},{"location":"reference/x86/#jumps","text":"machine code assembly description %377 $rel jmp $rel jump, rel : 8-bit relative address %351 #rel jmp #rel jump, rel : 32-bit relative address $7q $rel jq $rel conditional jump, q : condition, rel : 8-bit relative address Conditional jumps are easiest to write in hexadecimal. $7x corresponds to %16x or %17x in octal. Possible conditions are as follows: ID condition description 0 o signed overflow 1 no signed no overflow 2 c / b unsigned carry or < 3 nc / ae unsigned no carry or >= 4 e / z equal or zero 5 ne / nz not equal or not zero 6 be unsigned <= 7 a unsigned > 8 s signed < 0 9 ns signed >= 0 a p odd parity b np even parity c l signed < d ge signed >= e le signed <= f g signed >","title":"Jumps"},{"location":"reference/x86/#software-interrupts","text":"A system call is achieved by calling software interrupt $80 . machine code assembly description %315 $x int $x software interrupt number x","title":"Software interrupts"}]}